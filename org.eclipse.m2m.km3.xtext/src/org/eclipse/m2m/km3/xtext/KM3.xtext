// automatically generated by Xtext
grammar org.eclipse.m2m.km3.xtext.KM3 with org.eclipse.xtext.common.Terminals hidden(COMMENT, WS)

import "http://www.eclipse.org/m2m/km3" 
import "http://www.eclipse.org/m2m/km3/primitives" as PrimitiveTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Metamodel:
	{Metamodel} (contents+=Package)*;

Package:
	'package' name=ID
	'{'
		(contents+=ModelElement)*
	'}';

terminal COMMENT 	: '--' !('\n'|'\r')* ('\r'? '\n')?;

ModelElement:
	DataType | Class
//	Classifier_Impl | Enumeration | EnumLiteral | TemplateParameter | TypedElement_Impl | StructuralFeature_Impl | Attribute | Reference | Operation | Parameter | Package;
;

DataType:
	'datatype' name=ID ';';

StructuralFeature:
	Attribute | Reference
//	StructuralFeature_Impl;
;

Class:
	(isAbstract?='abstract')?
	'class' name=ID
		('extends' supertypes+=[Class] ( "," supertypes+=[Class])* )?
	'{'	(structuralFeatures+=StructuralFeature)*
	'}';

Attribute:
	(isUnique?='unique')?
	'attribute' name=ID
	('[' (lower=ElementBound '-')? upper=ElementBound ']')?
	(isOrdered ?= 'ordered')?
	':' type=[Classifier]
	';'
;

Reference:
	'reference' name=ID
	('[' (lower=ElementBound '-')? upper=ElementBound ']')?
	(isOrdered?='ordered')?
	(isContainer?='container')?
	':' type=[Classifier]
	('oppositeOf' opposite=[Reference])?
	';'
	;

ElementBound returns ecore::EIntegerObject: // datatype rule handled by a value converter
    '*' | INT;
//
//
//
//Classifier returns Classifier:
//	Classifier_Impl | DataType | Enumeration | TemplateParameter | Class;
//
//String0 returns PrimitiveTypes::String:
//	'String' /* TODO: implement this rule and an appropriate IValueConverter */;
//
//
//Classifier_Impl returns Classifier:
//	'Classifier'
//	'{'
//		'location' location=String0
//		'name' name=String0
//	'}';
//
//
//Enumeration returns Enumeration:
//	'Enumeration'
//	'{'
//		'location' location=String0
//		'name' name=String0
//		('literals' '(' literals+=[EnumLiteral|STRING] ( "," literals+=[EnumLiteral|STRING])* ')' )?
//	'}';
//
//EnumLiteral returns EnumLiteral:
//	'EnumLiteral'
//	'{'
//		'location' location=String0
//		'name' name=String0
//		'enum' ^enum=[Enumeration|STRING]
//	'}';
//
//TemplateParameter returns TemplateParameter:
//	'TemplateParameter'
//	'{'
//		'location' location=String0
//		'name' name=String0
//	'}';
//
//
//TypedElement_Impl returns TypedElement:
//	'TypedElement'
//	'{'
//		'location' location=String0
//		'name' name=String0
//		'lower' lower=Integer
//		'upper' upper=Integer
//		'isOrdered' isOrdered=Boolean
//		'isUnique' isUnique=Boolean
//		'type' type=[Classifier|STRING]
//	'}';
//
//StructuralFeature_Impl returns StructuralFeature:
//	'StructuralFeature'
//	'{'
//		'location' location=String0
//		'name' name=String0
//		'lower' lower=Integer
//		'upper' upper=Integer
//		'isOrdered' isOrdered=Boolean
//		'isUnique' isUnique=Boolean
//		'type' type=[Classifier|STRING]
//		'owner' owner=[Class|STRING]
//		('subsetOf' '(' subsetOf+=[StructuralFeature|STRING] ( "," subsetOf+=[StructuralFeature|STRING])* ')' )?
//		('derivedFrom' '(' derivedFrom+=[StructuralFeature|STRING] ( "," derivedFrom+=[StructuralFeature|STRING])* ')' )?
//	'}';
//
//
//Operation returns Operation:
//	'Operation'
//	'{'
//		'location' location=String0
//		'name' name=String0
//		'lower' lower=Integer
//		'upper' upper=Integer
//		'isOrdered' isOrdered=Boolean
//		'isUnique' isUnique=Boolean
//		'type' type=[Classifier|STRING]
//		'owner' owner=[Class|STRING]
//		('parameters' '(' parameters+=[Parameter|STRING] ( "," parameters+=[Parameter|STRING])* ')' )?
//	'}';
//
//Parameter returns Parameter:
//	'Parameter'
//	'{'
//		'location' location=String0
//		'name' name=String0
//		'lower' lower=Integer
//		'upper' upper=Integer
//		'isOrdered' isOrdered=Boolean
//		'isUnique' isUnique=Boolean
//		'type' type=[Classifier|STRING]
//		'owner' owner=[Operation|STRING]
//	'}';
//
//Boolean returns PrimitiveTypes::Boolean:
//	'Boolean' /* TODO: implement this rule and an appropriate IValueConverter */;
//
//Integer returns PrimitiveTypes::Integer:
//	'Integer' /* TODO: implement this rule and an appropriate IValueConverter */;
